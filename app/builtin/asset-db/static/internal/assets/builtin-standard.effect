// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

CCEffect {
  declarations: {
    p1: {
      tilingOffset:    { type: 'vec4',      value: [1.0, 1.0, 0.0, 0.0] }
      albedo:          { type: 'color4',    value: [1.0, 1.0, 1.0, 1.0] }
      albedoScale:     { type: 'vec4',      value: [1.0, 1.0, 1.0, 0.0] }
      pbrParams:       { type: 'vec4',      value: [0.6, 0.2, 1.0, 1.0] }
      pbrScale:        { type: 'vec4',      value: [1.0, 1.0, 1.0, 1.0] }
      emissive:        { type: 'color4',    value: [1.0, 1.0, 1.0, 1.0] }
      emissiveScale:   { type: 'vec4',      value: [1.0, 1.0, 1.0, 1.0] }
      albedoSampler:   { type: 'sampler2D', value: 'grey'               }
      normalSampler:   { type: 'sampler2D', value: 'normal'             }
      pbrSampler:      { type: 'sampler2D', value: 'grey'               }
      emissiveSampler: { type: 'sampler2D', value: 'grey'               }
    }
    planarShadow: {
      switch: USE_PLANAR_SHADOW
      vert: planar-shadow-vs:vert
      frag: planar-shadow-fs:frag
      depthStencilState: {
        depthTest: true
        depthWrite: false
      }
    }
  }
  techniques: [
    {
      name: opaque
      passes: [{
        vert: standard-vs:vert
        frag: standard-fs:frag
        properties: $p1
      }, '$planarShadow']
    }
    {
      name: transparent
      passes: [{
        vert: standard-vs:vert
        frag: standard-fs:frag
        depthStencilState: {
          depthTest: true
          depthWrite: false
        }
        blendState: {
          targets: [{
            blend: true
            blendSrc: src_alpha
            blendDst: one_minus_src_alpha
            blendDstAlpha: one_minus_src_alpha
          }]
        }
        properties: $p1
      }, '$planarShadow']
    }
  ]
}

CCProgram standard-vs {
  precision mediump float;
  #include <cc-global>
  #include <cc-local>

  #if CC_USE_SKINNING
    #include <skinning>
  #endif

  in vec3 a_position;
  in vec3 a_normal;
  out vec3 v_worldPos;
  out vec3 v_worldNormal;

  #if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP
    in vec2 a_texCoord;
    out vec2 v_uv;
  #endif

  uniform Constants {
    vec4 tilingOffset;
    vec4 albedo;
    vec4 albedoScale;   // rgb: albedo scale, a: cutoff,
    vec4 pbrParams;     // r: roughness, g: metallic
    vec4 pbrScale;      // r: roughness scale, g: metallic scale
    vec4 emissive;
    vec4 emissiveScale;
  };

  vec4 vert () {
    vec4 pos = vec4(a_position, 1.0);
    vec4 normal = vec4(a_normal, 0.0);

    #if CC_USE_SKINNING
      skinVertex(pos, normal);
    #endif

    v_worldPos = (cc_matWorld * pos).xyz;
    v_worldNormal = (cc_matWorldIT * normal).xyz;

    #if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP
      v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;
    #endif

    return cc_matViewProj * cc_matWorld * pos;
  }
}

CCProgram standard-fs {
  precision mediump float;
  #include <cc-global>
  #include <cc-forward-lights>
  #include <common>
  #include <gamma>
  #include <lighting>

  in vec3 v_worldPos;
  in vec3 v_worldNormal;

  #if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP
    in vec2 v_uv;
  #endif

  uniform Constants {
    vec4 tilingOffset;
    vec4 albedo;
    vec4 albedoScale;   // rgb: albedo scale, a: cutoff,
    vec4 pbrParams;     // r: roughness, g: metallic
    vec4 pbrScale;      // r: roughness scale, g: metallic scale
    vec4 emissive;
    vec4 emissiveScale;
  };

  #if USE_ALBEDO_MAP
    uniform sampler2D albedoSampler;
  #endif
  #if USE_NORMAL_MAP
    uniform sampler2D normalSampler;
  #endif
  #if USE_PBR_MAP
    uniform sampler2D pbrSampler;
  #endif
  #if USE_EMISSIVE_MAP
    uniform sampler2D emissiveSampler;
  #endif

  #if USE_NORMAL_MAP
    vec3 getNormal(vec3 pos, vec3 normal) {
      vec3 q0 = vec3( dFdx( pos.x ), dFdx( pos.y ), dFdx( pos.z ) );
      vec3 q1 = vec3( dFdy( pos.x ), dFdy( pos.y ), dFdy( pos.z ) );
      vec2 st0 = dFdx( v_uv.st );
      vec2 st1 = dFdy( v_uv.st );
      vec3 S = normalize( q0 * st1.t - q1 * st0.t );
      vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
      vec3 N = normal;
      vec3 mapN = texture(normalSampler, v_uv).rgb * 2.0 - 1.0;
      mapN.xy = 1.0 * mapN.xy;
      mat3 tsn = mat3( S, T, N );
      return normalize( tsn * mapN );
    }
  #endif

  vec4 frag () {
    #if USE_ALBEDO_MAP
      vec4 baseColor = texture(albedoSampler, v_uv);
    #else
      vec4 baseColor = albedo;
    #endif
    baseColor.rgb *= albedoScale.rgb;
    baseColor.rgb = SRGBToLinear(baseColor.rgb);

    #if USE_ALPHA_TEST
      if(baseColor.a < albedoScale.a)
        discard;
    #endif

    vec3 N = normalize(v_worldNormal);
    #if USE_NORMAL_MAP
      N = getNormal(v_worldPos, N);
    #endif

    #if USE_PBR_MAP
      vec4 pbr = texture(pbrSampler, v_uv);
    #else
      vec4 pbr = pbrParams;
    #endif
    pbr *= pbrScale;
    float roughness = clamp(pbr.r, 0.04, 1.0);
    float metallic = clamp(pbr.g, 0.0, 1.0);

    // Calculate diffuse & specular
    vec3 diffuse = baseColor.rgb * 0.96 * (1.0 - metallic);
    vec3 specular = mix(vec3(0.04), baseColor.rgb, metallic);

    vec3 V = normalize(cc_cameraPos.xyz - v_worldPos);
    vec3 L = normalize(-cc_mainLitDir.xyz);
    vec3 H = normalize(L+V);
    float NV = max(abs(dot(N, V)), 0.001);
    float NL = max(dot(N, L), 0.001);
    float NH = max(dot(N, H), 0.0);

    specular = BRDFApprox(specular, roughness, NV);

    vec3 R = normalize(reflect(-V, N));
    // float RL = max(dot(R, L), 0.0);
    vec3 specularContrib = specular * CalcSpecular(roughness, NH, H, N);

    // Cook-Torrance Microfacet Specular BRDF
    vec3 diffuseContrib = diffuse / PI;
    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w * (diffuseContrib + specularContrib);

    // Calculate lighting
    for (int i = 0; i < MAX_LIGHTS; i++) {
      /*
      // Diretional Lights
      vec3 dL = normalize(-cc_dirLightDirection[i].xyz);
      vec3 dH = normalize(dL+V);
      float dNL = max(dot(N, dL), 0.001);
      float dNH = max(dot(N, dH), 0.0);
      vec3 dSpec = specular * CalcSpecular(roughness, dNH, dH, N);
      finalColor += dNL * cc_dirLightColor[i].rgb * cc_dirLightColor[i].w * (diffuseContrib + dSpec);
      */

      // Sphere Lights
      vec3 PLU = cc_sphereLitPos[i].xyz - v_worldPos;
      vec3 PL = normalize(PLU);
      vec3 PH = normalize(PL+V);
      float PNL = max(dot(N, PL), 0.001);
      float PNH = max(dot(N, PH), 0.0);
      
      float pDistSqr = dot(PLU, PLU);
      float litRadius = cc_sphereLitSizeRange[i].x;
			float litRadiusSqr = litRadius * litRadius;
			float illum = PI * (litRadiusSqr / max(litRadiusSqr , pDistSqr));

      float pInvSqrAttRadius = 1.0 / max(cc_sphereLitSizeRange[i].y, 0.01);
      pInvSqrAttRadius *= pInvSqrAttRadius;
      float pAtt = SmoothDistAtt(pDistSqr, pInvSqrAttRadius);
      vec3 pSpec = specular * CalcSpecular(roughness, PNH, PH, N);
      finalColor += PNL * cc_sphereLitColor[i].rgb * cc_sphereLitColor[i].w * illum * pAtt * (diffuseContrib + pSpec);

      // Spot Lights
      vec3 SLU = cc_spotLitPosSize[i].xyz - v_worldPos;
      vec3 SL = normalize(SLU);
      vec3 SH = normalize(SL+V);
      float SNL = max(dot(N, SL), 0.001);
      float SNH = max(dot(N, SH), 0.0);
      float cosConeAngle = max(dot(-cc_spotLitDirRange[i].xyz, SL), 0.01);
      float sInvSqrAttRadius = 1.0 / max(cc_spotLitDirRange[i].w, 0.01);
      float sDistSqr = dot(SLU, SLU);
      float sAtt = GetDistAtt(sDistSqr, sInvSqrAttRadius);
      sAtt *= cosConeAngle;
      vec3 sSpec = specular * CalcSpecular(roughness, SNH, SH, N);
      finalColor += SNL * cc_spotLitColor[i].rgb * cc_spotLitColor[i].w * sAtt * (diffuseContrib + sSpec);
    }

    float fAmb = dot(N, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;
    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;
    finalColor += (ambDiff.rgb * diffuse);
    finalColor = max(finalColor, vec3(0.0));
    finalColor *= FP_SCALE;
    return vec4(finalColor, baseColor.a);
  }
}

CCProgram planar-shadow-vs {
  precision highp float;
  #include <cc-global>
  #include <cc-local>
  #include <cc-shadow>

  in vec3 a_position;

  vec4 vert () {
    vec4 pos = vec4(a_position, 1);
    return cc_matViewProj * cc_matLightPlaneProj * cc_matWorld * pos;
  }
}

CCProgram planar-shadow-fs {
  precision highp float;
  #include <cc-shadow>

  vec4 frag () {
    return cc_shadowColor;
  }
}
