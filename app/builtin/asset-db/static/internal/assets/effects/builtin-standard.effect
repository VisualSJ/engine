// Copyright (c) 2017-2019 Xiamen Yaji Software Co., Ltd.

CCEffect %{
  temporaries:
    s1: &s1 {
      minFilter: linear,
      magFilter: linear,
      mipFilter: linear,
      addressU: wrap,
      addressV: wrap,
    }
  techniques:
  - name: opaque
    passes:
    - vert: standard-vs:vert
      frag: standard-fs:frag
      properties: &props
        tilingOffset:  { value: [1.0, 1.0, 0.0, 0.0] }
        albedo:        { value: [1.0, 1.0, 1.0, 1.0], inspector: { type: color } }
        albedoScale:   { value: [1.0, 1.0, 1.0, 0.0] }
        pbrParams:     { value: [0.8, 0.6, 0.0, 1.0] }
        pbrScale:      { value: [1.0, 1.0, 1.0, 1.0] }
        emissive:      { value: [1.0, 1.0, 1.0, 1.0], inspector: { type: color } }
        emissiveScale: { value: [1.0, 1.0, 1.0, 1.0] }
        albedoMap:     { value: grey         }
        normalMap:     { value: normal       }
        pbrMap:        { value: grey         }
        emissiveMap:   { value: grey         }
        envMap:        { value: default-cube }
    - &planarShadow
      switch: USE_PLANAR_SHADOW
      vert: planar-shadow-vs:vert
      frag: planar-shadow-fs:frag
      # phase: planarShadow
      customizations: [ bounds-merge-shadow ]
      depthStencilState:
        depthTest: true
        depthWrite: false
        stencilTestFront: true
        stencilFuncFront: not_equal
        stencilPassOpFront: replace
        stencilRef: 0x80 # only use the leftmost bit
        stencilReadMask: 0x80
        stencilWriteMask: 0x80
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendDstAlpha: one_minus_src_alpha

  - name: transparent
    passes:
    - vert: standard-vs:vert
      frag: standard-fs:frag
      depthStencilState:
        depthTest: true
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendDstAlpha: one_minus_src_alpha
      properties: *props
    - *planarShadow
}%

CCProgram shared-ubos %{
  uniform Constants {
    vec4 tilingOffset;
    vec4 albedo;
    vec4 albedoScale;   // rgb: albedo scale, a: cutoff,
    vec4 pbrParams;     // r: roughness, g: metallic (follow CHANNEL defines)
    vec4 pbrScale;      // r: roughness scale, g: metallic scale (follow CHANNEL defines)
    vec4 emissive;
    vec4 emissiveScale;
  };
}%

CCProgram standard-vs %{
  precision mediump float;
  #include <cc-global>
  #include <cc-local>
  #include <shared-ubos>

  #if CC_USE_SKINNING
    #include <cc-skinning>
  #endif

  in vec3 a_position;
  in vec3 a_normal;
  in vec4 a_tangent;
  out vec3 v_worldPos;
  out vec3 v_worldNormal;

  #if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP
    in vec2 a_texCoord;
    out vec2 v_uv;
  #endif

  #if USE_NORMAL_MAP
    out vec3 v_tangent;
  #endif

  vec4 vert () {
#if CC_USE_SKINNING
    highp
#endif
    vec4 pos = vec4(a_position, 1.0);
    vec4 normal = vec4(a_normal, 0.0);

    #if CC_USE_SKINNING
      skinVertex(pos, normal);
    #else
      pos = cc_matWorld * pos;
      normal = cc_matWorldIT * normal;
    #endif

    v_worldPos = pos.xyz;
    v_worldNormal = normal.xyz;

    #if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP
      v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;
    #endif

    #if USE_NORMAL_MAP
      v_tangent = (cc_matWorldIT * vec4(a_tangent.xyz, 0.0)).xyz;
    #endif

    return cc_matViewProj * pos;
  }
}%

CCProgram standard-fs %{
  precision mediump float;
  #include <cc-global>
  #include <cc-forward-light>
  #include <common>
  #include <gamma>
  #include <lighting>
  #include <shared-ubos>

  in vec3 v_worldPos;
  in vec3 v_worldNormal;

  #if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP
    in vec2 v_uv;
  #endif

  #if USE_NORMAL_MAP
    in vec3 v_tangent;
  #endif

  #if USE_ALBEDO_MAP
    uniform sampler2D albedoMap;
  #endif
  #if USE_NORMAL_MAP
    uniform sampler2D normalMap;
  #endif
  #if USE_PBR_MAP
    uniform sampler2D pbrMap;
  #endif
  #if USE_EMISSIVE_MAP
    uniform sampler2D emissiveMap;
  #endif
  #ifdef USE_IBL
    uniform samplerCube envMap;
  #endif

  #pragma define ROUGHNESS_CHANNEL options([r, g, b, a])
  #pragma define METALLIC_CHANNEL  options([g, r, b, a])
  #pragma define AO_CHANNEL        options([b, r, g, a])

  vec4 frag () {
    #if USE_ALBEDO_MAP
      vec4 baseColor = texture(albedoMap, v_uv) * albedo;
    #else
      vec4 baseColor = albedo;
    #endif
    baseColor.rgb *= albedoScale.rgb;
    baseColor.rgb = SRGBToLinear(baseColor.rgb);

    #if USE_ALPHA_TEST
      if(baseColor.a < albedoScale.a)
        discard;
    #endif

    vec3 N = normalize(v_worldNormal);
    #if USE_NORMAL_MAP
      vec3 normal = texture(normalMap, v_uv).rgb;
      normal = 2.0 * normal.xyz - 1.0;

      vec3 tangent = normalize(v_tangent);
      vec3 binormal = normalize(cross(tangent, N));
      mat3 matTBN = mat3(tangent, binormal, N);
      N = normalize(matTBN * normal);
    #endif

    #if USE_PBR_MAP
      vec4 pbr = texture(pbrMap, v_uv);
    #else
      vec4 pbr = pbrParams;
    #endif
    pbr *= pbrScale;
    float roughness = clamp(pbr.ROUGHNESS_CHANNEL, 0.04, 1.0);
    float metallic = clamp(pbr.METALLIC_CHANNEL, 0.0, 0.96);

    // Calculate diffuse & specular
    vec3 diffuse = baseColor.rgb * (1.0 - metallic);
    vec3 specular = mix(vec3(0.04), baseColor.rgb, metallic);

    vec3 V = normalize(cc_cameraPos.xyz - v_worldPos);
    vec3 L = normalize(-cc_mainLitDir.xyz);
    vec3 H = normalize(L+V);
    float NV = max(abs(dot(N, V)), 0.001);
    float NL = max(dot(N, L), 0.001);
    float NH = max(dot(N, H), 0.0);

    specular = BRDFApprox(specular, roughness, NV);

    // vec3 R = normalize(reflect(-V, N));
    // float RL = max(dot(R, L), 0.0);
    vec3 specularContrib = specular * CalcSpecular(roughness, NH, H, N);

    // Cook-Torrance Microfacet Specular BRDF
    vec3 diffuseContrib = diffuse / PI;
    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w * (diffuseContrib + specularContrib);

    // Calculate lighting
    for (int i = 0; i < MAX_LIGHTS; i++) {
      // Sphere Lights
      vec3 PLU = cc_sphereLitPos[i].xyz - v_worldPos;
      vec3 PL = normalize(PLU);
      vec3 PH = normalize(PL+V);
      float PNL = max(dot(N, PL), 0.001);
      float PNH = max(dot(N, PH), 0.0);

      float distSqr = dot(PLU, PLU);
      float litRadius = cc_sphereLitSizeRange[i].x;
			float litRadiusSqr = litRadius * litRadius;
			float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));
      float attRadiusSqrInv = 1.0 / max(cc_sphereLitSizeRange[i].y, 0.01);
      attRadiusSqrInv *= attRadiusSqrInv;
      float att = GetDistAtt(distSqr, attRadiusSqrInv);
      vec3 lspec = specular * CalcSpecular(roughness, PNH, PH, N);
      finalColor += PNL * cc_sphereLitColor[i].rgb * cc_sphereLitColor[i].w * illum * att * (diffuseContrib + lspec);
    }

    for (int i = 0; i < MAX_LIGHTS; i++) {
      // Spot Lights
      vec3 SLU = cc_spotLitPos[i].xyz - v_worldPos;
      vec3 SL = normalize(SLU);
      vec3 SH = normalize(SL+V);
      float SNL = max(dot(N, SL), 0.001);
      float SNH = max(dot(N, SH), 0.0);

      float distSqr = dot(SLU, SLU);
      float litRadius = cc_spotLitSizeRangeAngle[i].x;
			float litRadiusSqr = litRadius * litRadius;
			float illum = PI * (litRadiusSqr / max(litRadiusSqr , distSqr));
      float attRadiusSqrInv = 1.0 / max(cc_spotLitSizeRangeAngle[i].y, 0.01);
      attRadiusSqrInv *= attRadiusSqrInv;

      float cosInner = max(dot(-cc_spotLitDir[i].xyz, SL), 0.01);
      float cosOuter = cc_spotLitSizeRangeAngle[i].z;
      float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);
      float litAngleOffset = -cosOuter * litAngleScale;
      float att = GetDistAtt(distSqr, attRadiusSqrInv);
      att *= GetAngleAtt(SL, -cc_spotLitDir[i].xyz, litAngleScale, litAngleOffset);

      vec3 lspec = specular * CalcSpecular(roughness, SNH, SH, N);
      finalColor += SNL * cc_spotLitColor[i].rgb * cc_spotLitColor[i].w * illum * att * (diffuseContrib + lspec);
    }

    float fAmb = dot(N, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;
    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;
    finalColor += (ambDiff.rgb * diffuse);

    #if USE_IBL
      vec3 R = normalize(reflect(-V, N));
      vec4 env = texture(envMap, R);
      env.rgb = SRGBToLinear(env.rgb) * cc_ambientSky.w;
      finalColor += (env.rgb * specular);
    #endif

    finalColor = mix(finalColor, finalColor * pbr.AO_CHANNEL, pbrParams.z);

    #if USE_EMISSIVE_MAP
      vec3 emissiveColor = texture(emissiveMap, v_uv).rgb;
      emissiveColor = SRGBToLinear(emissiveColor);

    #if CC_USE_HDR
      emissiveColor *= cc_exposure.w;
    #endif

      finalColor += emissiveColor * emissive.rgb * emissiveScale.xyz;
    #endif

    #if !CC_USE_HDR
      finalColor = LinearToSRGB(finalColor);
    #endif
    return vec4(finalColor, baseColor.a);
  }
}%

CCProgram planar-shadow-vs %{
  precision mediump float;
  #include <cc-global>
  #include <cc-local>
  #include <cc-shadow>
  #if CC_USE_SKINNING
    #include <cc-skinning>
  #endif

  in vec3 a_position;

  vec4 vert () {
#if CC_USE_SKINNING
    highp
#endif
    vec4 pos = vec4(a_position, 1);

    #if CC_USE_SKINNING
      skinVertex(pos);
    #else
      pos = cc_matWorld * pos;
    #endif

    pos = cc_matViewProj * cc_matLightPlaneProj * pos;
    pos.z -= 0.0001;
    return pos;
  }
}%

CCProgram planar-shadow-fs %{
  precision mediump float;
  #include <cc-shadow>
  #include <post-process>

  vec4 frag () {
    return PostProcess(cc_shadowColor);
  }
}%
