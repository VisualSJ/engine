// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
CCEFFECT {
  declarations: {
    p1: {
      diffuseColor:       { type: 'color4',    value: [0.3, 0.3, 0.3, 1] }
      tilingOffset:       { type: 'vec4',      value: [1, 1, 0, 0]       }
      diffuse_texture:    { type: 'sampler2D', value: 'grey'             }
      specularColor:      { type: 'color4',    value: [0, 0, 0, 0]       }
      specular_texture:   { type: 'sampler2D', value: 'grey'             }
      emissiveColor:      { type: 'color4',    value: [0, 0, 0, 0]       }
      emissive_texture:   { type: 'sampler2D', value: 'grey'             }
      glossAlphaTest:     { type: 'vec4',      value: [10, 0, 0, 0]      }
      normal_texture:     { type: 'sampler2D', value: 'normal'           }
    }
  }
  techniques: [
    {
      name: opaque
      passes: [
        {
          vert: phong-vs:vert
          frag: phong-fs:frag
          properties: $p1
        }
      ]
    }
    {
      name: transparent
      passes: [
        {
          vert: phong-vs:vert
          frag: phong-fs:frag
          depthStencilState: {
            depthTest: true
            depthWrite: false
          }
          blendState: {
            targets: [
              {
                blend: true
                blendSrc: src_alpha
                blendDst: one_minus_src_alpha
                blendDstAlpha: one_minus_src_alpha
              }
            ]
          }
          properties: $p1
        }
      ]
    }
  ]
}

CCPROGRAM phong-vs {
  precision mediump float;
  #include <cc-global>
  #include <cc-local>

  #if CC_USE_SKINNING
    #include <skinning>
  #endif

  in vec3 a_position;
  in vec3 a_normal;
  out vec3 normal_w;
  out vec3 pos_w;

  #if USE_DIFFUSE_TEXTURE || USE_NORMAL_TEXTURE || USE_EMISSIVE_TEXTURE
    in vec2 a_texCoord;
    out vec2 uv0;
  #endif

  uniform TexCoords {
    vec4 tilingOffset;
  };

  vec4 vert () {
    vec4 pos = vec4(a_position, 1);
    vec4 normal = vec4(a_normal, 0);

    #if CC_USE_SKINNING
      skinVertex(pos, normal);
    #endif

    pos_w = (cc_matWorld * pos).xyz;
    normal_w = (cc_matWorldIT * normal).xyz;

    #if USE_DIFFUSE_TEXTURE || USE_NORMAL_TEXTURE || USE_EMISSIVE_TEXTURE
      uv0 = a_texCoord * tilingOffset.xy + tilingOffset.zw;
    #endif

    return cc_matViewProj * cc_matWorld * pos;
  }
}

CCPROGRAM phong-fs {
  precision mediump float;
  #include <cc-global>
  #include <gamma-correction>
  #include <phong-lighting>

  in vec3 normal_w;
  in vec3 pos_w;

  #if USE_DIFFUSE_TEXTURE || USE_NORMAL_TEXTURE || USE_EMISSIVE_TEXTURE
    in vec2 uv0;
  #endif

  uniform Constants {
    vec4 diffuseColor;
    vec4 emissiveColor;
    vec4 specularColor;
    vec4 glossAlphaTest;
  };

  #if USE_DIFFUSE_TEXTURE
    uniform sampler2D diffuse_texture;
  #endif

  #if USE_EMISSIVE && USE_EMISSIVE_TEXTURE
    uniform sampler2D emissive_texture;
  #endif

  #if USE_SPECULAR && USE_SPECULAR_TEXTURE
    uniform sampler2D specular_texture;
  #endif

  #if USE_NORMAL_TEXTURE
    uniform sampler2D normal_texture;
    vec3 getNormal(vec3 pos, vec3 normal) {
      vec3 q0 = vec3( dFdx( pos.x ), dFdx( pos.y ), dFdx( pos.z ) );
      vec3 q1 = vec3( dFdy( pos.x ), dFdy( pos.y ), dFdy( pos.z ) );
      vec2 st0 = dFdx( uv0.st );
      vec2 st1 = dFdy( uv0.st );
      vec3 S = normalize( q0 * st1.t - q1 * st0.t );
      vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
      vec3 N = normal;
      vec3 mapN = texture(normal_texture, uv0).rgb * 2.0 - 1.0;
      mapN.xy = 1.0 * mapN.xy;
      mat3 tsn = mat3( S, T, N );
      return normalize( tsn * mapN );
    }
  #endif

  struct phongMaterial {
    vec3 diffuse;
    vec3 emissive;
    vec3 specular;
    float glossiness;
    float opacity;
  };

  phongMaterial getPhongMaterial() {
    phongMaterial result;

    #if USE_DIFFUSE_TEXTURE
      vec4 baseColor = diffuseColor * gammaToLinearSpaceRGBA(texture(diffuse_texture, uv0));
      result.diffuse = baseColor.rgb;
      result.opacity = baseColor.a;
    #else
      result.diffuse = diffuseColor.rgb;
      result.opacity = diffuseColor.a;
    #endif

    #if USE_EMISSIVE
      result.emissive = emissiveColor.rgb;
      #if USE_EMISSIVE_TEXTURE
        result.emissive *= gammaToLinearSpaceRGB(texture(emissive_texture, uv0).rgb);
      #endif
    #endif

    #if USE_SPECULAR
      result.specular = specularColor.rgb;
      #if USE_SPECULAR_TEXTURE
        result.specular = gammaToLinearSpaceRGB(texture(specular_texture, uv0).rgb);
      #endif

      result.glossiness = glossAlphaTest.x;
    #endif

    return result;
  }

  vec4 composePhongShading(Lighting lighting, phongMaterial mtl, float shadow) {
    vec4 o = vec4(0.0, 0.0, 0.0, 1.0);

    //diffuse is always calculated
    o.xyz = lighting.diffuse * mtl.diffuse;
    #if USE_EMISSIVE
      o.xyz += mtl.emissive;
    #endif
    #if USE_SPECULAR
      o.xyz += lighting.specular * mtl.specular;
    #endif
    o.xyz *= shadow;
    o.w = mtl.opacity;

    return o;
  }

  vec4 frag () {
    Lighting phongLighting;
    vec3 viewDirection = normalize(cc_cameraPos.xyz - pos_w);

    phongMaterial mtl = getPhongMaterial();
    #if USE_ALPHA_TEST
      if(mtl.opacity < glossAlphaTest.y) discard;
    #endif
    vec3 normal = normalize(normal_w);
    #if USE_NORMAL_TEXTURE
      normal = getNormal(pos_w, normal);
    #endif
    phongLighting = getPhongLighting(pos_w, normal, viewDirection, mtl.glossiness);
    phongLighting.diffuse += vec3(0.5); // scene ambient

    vec4 finalColor = composePhongShading(phongLighting, mtl, 1.0);

    return linearToGammaSpaceRGBA(finalColor);
  }
}
