// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

CCEffect {
	declarations: {
		p1: {
			tilingOffset:		{ type: 'vec4',			value: [1.0, 1.0, 0.0, 0.0] }
			albedo:				{ type: 'color4',		value: [1.0, 1.0, 1.0, 1.0] }
			albedoScale:		{ type: 'vec4',			value: [1.0, 1.0, 1.0, 0.0] }
			pbrParams:			{ type: 'vec4',			value: [0.6, 0.2, 1.0, 1.0] }
			pbrScale:			{ type: 'vec4',			value: [1.0, 1.0, 1.0, 1.0] }
			emissive:			{ type: 'color4',		value: [1.0, 1.0, 1.0, 1.0] }
			emissiveScale:		{ type: 'vec4',			value: [1.0, 1.0, 1.0, 1.0] }
			albedoSampler:		{ type: 'sampler2D',	value: 'grey' }
			normalSampler:		{ type: 'sampler2D',	value: 'normal' }
			pbrSampler:			{ type: 'sampler2D',	value: 'grey' }
			emissiveSampler:	{ type: 'sampler2D',	value: 'grey' }
		}
	}
	techniques: [
    {
		name: opaque
		passes: [{
			vert: standard-vs:vert
			frag: standard-fs:frag
			properties: $p1
		}]
    }
    {
		name: transparent
    	passes: [{
			vert: standard-vs:vert
			frag: standard-fs:frag
			depthStencilState: {
				depthTest: true
				depthWrite: false
			}
        	blendState: {
            	targets: [{
					blend: true
					blendSrc: src_alpha
					blendDst: one_minus_src_alpha
					blendDstAlpha: one_minus_src_alpha
            	}]
        	}
        	properties: $p1
        }]
	}]
}

CCProgram standard-vs {

precision mediump float;
#include <cc-global>
#include <cc-local>

#if CC_USE_SKINNING
#include <skinning>
#endif

in vec3 a_position;
in vec3 a_normal;
out vec3 v_worldPos;
out vec3 v_worldNormal;

#if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP
in vec2 a_texCoord;
out vec2 v_uv;
#endif

uniform Constants {
	vec4 tilingOffset;
	vec4 albedo;
	vec4 albedoScale;	// rgb: albedo scale, a: cutoff, 
	vec4 pbrParams;		// r: roughness, g: metallic
	vec4 pbrScale;		// r: roughness scale, g: metallic scale
	vec4 emissive;
	vec4 emissiveScale;
};

vec4 vert () {
	vec4 pos = vec4(a_position, 1.0);
	vec4 normal = vec4(a_normal, 0.0);

	#if CC_USE_SKINNING
		skinVertex(pos, normal);
	#endif

	v_worldPos = (cc_matWorld * pos).xyz;
	v_worldNormal = (cc_matWorldIT * normal).xyz;

	#if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP
		v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;
	#endif

	return cc_matViewProj * cc_matWorld * pos;
}

}

CCProgram standard-fs {
precision mediump float;
#include <cc-global>
#include <common>
#include <gamma>
#include <lighting>

in vec3 v_worldPos;
in vec3 v_worldNormal;

#if USE_ALBEDO_MAP || USE_NORMAL_MAP || USE_PBR_MAP || USE_EMISSIVE_MAP
in vec2 v_uv;
#endif

uniform Constants {
	vec4 tilingOffset;
	vec4 albedo;
	vec4 albedoScale;	// rgb: albedo scale, a: cutoff, 
	vec4 pbrParams;		// r: roughness, g: metallic
	vec4 pbrScale;		// r: roughness scale, g: metallic scale
	vec4 emissive;
	vec4 emissiveScale;
};

#if USE_ALBEDO_MAP
uniform sampler2D albedoSampler;
#endif
#if USE_NORMAL_MAP
uniform sampler2D normalSampler;
#endif
#if USE_PBR_MAP
uniform sampler2D pbrSampler;
#endif
#if USE_EMISSIVE_MAP
uniform sampler2D emissiveSampler;
#endif

#if USE_NORMAL_MAP
vec3 getNormal(vec3 pos, vec3 normal) {
	vec3 q0 = vec3( dFdx( pos.x ), dFdx( pos.y ), dFdx( pos.z ) );
	vec3 q1 = vec3( dFdy( pos.x ), dFdy( pos.y ), dFdy( pos.z ) );
	vec2 st0 = dFdx( v_uv.st );
	vec2 st1 = dFdy( v_uv.st );
	vec3 S = normalize( q0 * st1.t - q1 * st0.t );
	vec3 T = normalize( -q0 * st1.s + q1 * st0.s );
	vec3 N = normal;
	vec3 mapN = texture(normalSampler, v_uv).rgb * 2.0 - 1.0;
	mapN.xy = 1.0 * mapN.xy;
	mat3 tsn = mat3( S, T, N );
	return normalize( tsn * mapN );
}
#endif

vec4 frag () {
	#if USE_ALBEDO_MAP
	vec4 baseColor = texture(albedoSampler, v_uv);
	#else
	vec4 baseColor = albedo;
	#endif
	baseColor.rgb *= albedoScale.rgb;
	baseColor.rgb = SRGBToLinear(baseColor.rgb);

	#if USE_ALPHA_TEST
		if(baseColor.a < albedoScale.a)
			discard;
	#endif

	vec3 N = normalize(v_worldNormal);
	#if USE_NORMAL_MAP
		N = getNormal(v_worldPos, N);
	#endif

	#if USE_PBR_MAP
	vec4 pbr = texture(pbrSampler, v_uv);
	#else
	vec4 pbr = pbrParams;
	#endif
	pbr *= pbrScale;
	float roughness = clamp(pbr.r, 0.04, 1.0);
	float metallic = clamp(pbr.g, 0.0, 1.0);

	// calculate diffuse & specular
	vec3 diffuse = baseColor.rgb * 0.96 * (1.0 - metallic);
	vec3 specular = mix(vec3(0.04), baseColor.rgb, metallic);

	vec3 V = normalize(cc_cameraPos.xyz - v_worldPos);
	vec3 L = normalize(-cc_mainLitDir.xyz);
	vec3 H = normalize(L+V);
	float NV = clamp(dot(N, V), 0.0, 1.0);
	float NL = clamp(dot(N, L), 0.0, 1.0);
	float NH = clamp(dot(N, H), 0.0, 1.0);

	specular = BRDFApprox(specular, roughness, NV);

	vec3 R = normalize(reflect(-V, N));
	float RL = clamp(dot(R, L), 0.0, 1.0);
	vec3 specularContrib = specular * CalcSpecular(roughness, RL, NH, H, N);

	// Cook-Torrance Microfacet Specular BRDF
	vec3 diffuseContrib = diffuse / PI;
	vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w * (diffuseContrib + specularContrib);
	
	float fAmb = dot(N, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;
	vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;
	finalColor += (ambDiff.rgb * diffuse);

	finalColor = LinearToSRGB(finalColor);
	finalColor = max(finalColor, vec3(pbrParams.g));

	return vec4(finalColor, baseColor.a);
}

}