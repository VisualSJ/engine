// Copyright (c) 2017-2018 Xiamen Yaji Software Co. Ltd.
CCEFFECT {
  declarations: {
    p1: {
      albedo:              { type: 'color4',      value: [1, 1, 1, 1]     }
      tilingOffset:        { type: 'vec4',        value: [1, 1, 0, 0]     }
      props:               { type: 'vec4',        value: [0.5, 0.1, 1, 9] }
      emissive:            { type: 'color4',      value: [0, 0, 0, 0]     }
      albedo_texture:      { type: 'sampler2D',   value: 'grey'           }
      metallic_texture:    { type: 'sampler2D',   value: 'grey'           }
      roughness_texture:   { type: 'sampler2D',   value: 'grey'           }
      ao_texture:          { type: 'sampler2D',   value: 'grey'           }
      mra_texture:         { type: 'sampler2D',   value: 'grey'           }
      emissive_texture:    { type: 'sampler2D',   value: 'grey'           }
      normal_texture:      { type: 'sampler2D',   value: 'normal'         }
      diffuseEnvTexture:   { type: 'samplerCube', value: 'default-cube'   }
      specularEnvTexture:  { type: 'samplerCube', value: 'default-cube', sampler: { mipFilter: 'linear' } }
      brdfLUT:             { type: 'sampler2D',   value: 'grey'           }
    }
  }
  techniques: [
    {
      name: opaque
      passes: [
        {
          vert: pbr-vs:vert
          frag: pbr-fs:frag
          properties: $p1
        }
      ]
    }
    {
      name: transparent
      passes: [
        {
          vert: pbr-vs:vert
          frag: pbr-fs:frag
          depthStencilState: {
            depthTest: true
            depthWrite: false
          }
          blendState: {
            targets: [
              {
                blend: true
                blendSrc: src_alpha
                blendDst: one_minus_src_alpha
                blendDstAlpha: one_minus_src_alpha
              }
            ]
          }
          properties: $p1
        }
      ]
    }
  ]
}

CCPROGRAM pbr-vs {
  precision mediump float;
  #include <cc-global>
  #include <cc-local>
  #if CC_USE_SKINNING
    #include <skinning>
  #endif

  #if USE_ALBEDO_TEXTURE || USE_NORMAL_TEXTURE || USE_MRA_TEXTURE || USE_METALLIC_TEXTURE || USE_ROUGHNESS_TEXTURE || USE_AO_TEXTURE || USE_MRA_TEXTURE || USE_EMISSIVE_TEXTURE
    in vec2 a_texCoord;
    out vec2 uv0;
  #endif
  in vec3 a_position;
  in vec3 a_normal;
  out vec3 pos_w;
  out vec3 normal_w;

  uniform TexCoords {
    vec4 tilingOffset;
  };

  vec4 vert () {
    vec4 pos = vec4(a_position, 1);
    vec4 normal = vec4(a_normal, 0);

    #if CC_USE_SKINNING
      skinVertex(pos, normal);
    #endif

    pos_w = (cc_matWorld * pos).xyz;
    normal_w = (cc_matWorldIT * normal).xyz;

    #if USE_ALBEDO_TEXTURE || USE_NORMAL_TEXTURE || USE_MRA_TEXTURE || USE_METALLIC_TEXTURE || USE_ROUGHNESS_TEXTURE || USE_AO_TEXTURE || USE_MRA_TEXTURE || USE_EMISSIVE_TEXTURE
      uv0 = a_texCoord * tilingOffset.xy + tilingOffset.zw;
    #endif

    return cc_matViewProj * cc_matWorld * pos;
  }
}

CCPROGRAM pbr-fs {
  precision mediump float;
  #include <cc-global>
  #include <pbr-lighting>
  #include <gamma-correction>
  #include <unpack>

  in vec3 pos_w;
  in vec3 normal_w;

  #if USE_ALBEDO_TEXTURE || USE_NORMAL_TEXTURE || USE_MRA_TEXTURE || USE_METALLIC_TEXTURE || USE_ROUGHNESS_TEXTURE || USE_AO_TEXTURE || USE_EMISSIVE_TEXTURE
    in vec2 uv0;
  #endif

  #if USE_IBL
    uniform samplerCube diffuseEnvTexture;
    uniform samplerCube specularEnvTexture;
    uniform sampler2D brdfLUT;
  #endif

  uniform Constants {
    vec4 albedo;
    vec4 props; // metallic, roughness, ao, maxReflectionLod
    vec4 emissive; // emissive.rgb, alphaTestThreshold
  };

  // material parameters
  #if USE_ALBEDO_TEXTURE
    uniform sampler2D albedo_texture;
  #endif

  #if USE_MRA_TEXTURE
    uniform sampler2D mra_texture;
  #endif

  #if USE_METALLIC_TEXTURE
    uniform sampler2D metallic_texture;
  #endif

  #if USE_ROUGHNESS_TEXTURE
    uniform sampler2D roughness_texture;
  #endif

  #if USE_AO_TEXTURE
    uniform sampler2D ao_texture;
  #endif

  #if USE_EMISSIVE_TEXTURE
    uniform sampler2D emissive_texture;
  #endif

  #if USE_NORMAL_TEXTURE
    uniform sampler2D normal_texture;
    // get world-space normal from normal texture
    vec3 getNormalFromTexture() {
      vec3 tangentNormal = texture(normal_texture, uv0).rgb * 2.0 - 1.0;
      vec3 q1  = dFdx(pos_w);
      vec3 q2  = dFdy(pos_w);
      vec2 st1 = dFdx(uv0);
      vec2 st2 = dFdy(uv0);
      vec3 N   = normalize(normal_w);
      vec3 T   = normalize(q1*st2.t - q2*st1.t);
      vec3 B   = -normalize(cross(N, T));
      mat3 TBN = mat3(T, B, N);

      return normalize(TBN * tangentNormal);
    }
  #endif

  vec4 frag() {
    float opacity = 1.0;
    float metallic = props.x;
    float roughness = props.y;
    float ao = props.z;

    #if USE_ALBEDO_TEXTURE
      vec4 baseColor = albedo * gammaToLinearSpaceRGBA(texture(albedo_texture, uv0));
      vec3 albedo = baseColor.rgb;
      opacity = baseColor.a;
    #else
      opacity = albedo.a;
      vec3 albedo = albedo.rgb;
    #endif

    #if USE_ALPHA_TEST
      if(opacity < emissive.w) discard;
    #endif

    #if USE_MRA_TEXTURE
      vec3 metalRoughness = texture(mra_texture, uv0).rgb;
      metallic = metalRoughness.r;
      roughness = metalRoughness.g;
      ao = metalRoughness.b;
    #else
      #if USE_METALLIC_TEXTURE
        metallic  = texture(metallic_texture, uv0).r;
      #endif
      #if USE_ROUGHNESS_TEXTURE
        roughness  = texture(roughness_texture, uv0).r;
      #endif
      #if USE_AO_TEXTURE
        ao  = texture(ao_texture, uv0).r;
      #endif
    #endif

    vec3 N = normalize(normal_w);
    #if USE_NORMAL_TEXTURE
      N = getNormalFromTexture();
    #endif
    vec3 V = normalize(cc_cameraPos.xyz - pos_w);

    // calculate reflectance at normal incidence; if dia-electric (like plastic) use F0
    // of 0.04 and if it's a metal, use the albedo color as F0 (metallic workflow)
    vec3 F0 = vec3(0.04);
    F0 = mix(F0, albedo, metallic);

    vec3 Lo = getPBRLighting(pos_w, N, V, F0, albedo, metallic, roughness);

    vec3 emissiveColor = emissive.rgb;
    #if USE_EMISSIVE_TEXTURE
      emissiveColor *= gammaToLinearSpaceRGB(texture(emissive_texture, uv0).rgb);
    #endif
    Lo += emissiveColor;

    // ambient lighting, will be replaced by IBL if IBL used.
    vec3 ambient = vec3(0.03) * albedo * ao;

    #if USE_IBL
      // generate ambient when using IBL.
      vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);
      vec3 kS = F;
      vec3 kD = vec3(1.0) - kS;
      kD *= 1.0 - metallic;
      #if USE_RGBE_IBL_DIFFUSE
        vec3 diffuseEnv = unpackRGBE(texture(diffuseEnvTexture, N));
      #else
        vec3 diffuseEnv = texture(diffuseEnvTexture, N).rgb;
      #endif
      vec3 diffuse = diffuseEnv * albedo;
      // sample both the specularEnvTexture and the BRDF lut and combine them together as per the Split-Sum approximation to get the IBL specular part.
      vec3 R = reflect(-V, N);
      #if USE_TEX_LOD
        vec4 speColor = textureLod(specularEnvTexture, R, roughness * props.w);
      #else
        vec4 speColor = texture(specularEnvTexture, R);
      #endif
      #if USE_RGBE_IBL_SPECULAR
        vec3 specularEnv = unpackRGBE(speColor);
      #else
        vec3 specularEnv = speColor.rgb;
      #endif
      vec2 brdf  = texture(brdfLUT, vec2(max(dot(N, V), 0.0), 1.0 - roughness)).rg;
      vec3 specular = specularEnv * (F * brdf.x + brdf.y);
      ambient = (kD * diffuse + specular) * ao;
    #endif

    vec3 color = ambient + Lo;

    // HDR tone mapping.
    color = color / (color + vec3(1.0));
    // gamma correction.
    vec4 finalColor = vec4(color, opacity);

    return linearToGammaSpaceRGBA(finalColor);
  }
}
